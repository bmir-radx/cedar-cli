package org.metadatacenter.cedar.cli;

import com.google.common.base.Charsets;
import org.metadatacenter.cedar.api.*;
import org.metadatacenter.cedar.bioportal.GetClassesRequest;
import org.metadatacenter.cedar.csv.*;
import org.metadatacenter.cedar.io.PostedArtifactResponse;
import org.metadatacenter.cedar.io.CedarArtifactPoster;
import org.metadatacenter.cedar.webapi.CreateFolderRequest;
import org.springframework.stereotype.Component;
import org.springframework.util.ResourceUtils;
import picocli.CommandLine;
import picocli.CommandLine.ArgGroup;
import picocli.CommandLine.Command;
import picocli.CommandLine.Option;

import java.io.IOException;
import java.io.PrintWriter;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

/**
 * Matthew Horridge
 * Stanford Center for Biomedical Informatics Research
 * 2022-07-29
 */
@Component
@Command(name = "csv2artifacts",
        description = "Generate CEDAR artifacts from a Comma Separated Values (CSV) file.  Artifacts are generated as CEDAR JSON-LD and are output as a set of JSON files.  Artifacts can also pushed directly into CEDAR.")
public class Csv2ArtifactsCommand implements CedarCliCommand {

    @Option(names = "--in", required = true, description = "A path to a CSV file that conforms to the CEDAR CSV format.")
    Path inputCsvFile;

    @Option(names = "--out", required = true, description = "A path to a local directory where JSON-LD CEDAR representations of CEDAR artifacts will be written to.")
    Path outputDirectory;

    @Option(names = "--overwrite", defaultValue = "false",
            description = "Force generated artifacts to be locally overwritten if the local output directory is not empty")
    boolean overwrite;

    @Option(names = "--json-schema-description", description = "A string that will be inserted into the JSON-Schema 'description' property of all generated CEDAR artifact objects.", defaultValue = "Generated by CSV2CEDAR.")
    String jsonSchemaDescription;

    @Option(names = "--artifact-status",
            description = "Specifies the status of the artifacts that are generated.  Valid values are ${COMPLETION-CANDIDATES}",
            defaultValue = "DRAFT",
            showDefaultValue = CommandLine.Help.Visibility.ALWAYS)
    ArtifactStatus artifactStatus;

    @Option(names = "--artifact-version",
            required = true,
            description = "A string in the format major.minor.patch that specifies the version number for generatated artifacts")
    String version;

    @Option(names = "--generate-fields", defaultValue = "false",
            description = "Specifies that CEDAR template fields should be individually generated.")
    boolean generateFields;

    @Option(names = "--generate-elements", defaultValue = "false",
            description = "Specifies that individual CEDAR template elements should be individually generated.")
    boolean generateElements;

    @CommandLine.Mixin
    BioPortalApiKeyMixin bioportalApiKey;

    @Option(names = "--artifact-previous-version", defaultValue = "", hidden = true)
    public String previousVersion;

    @ArgGroup(exclusive = false)
    public PostToCedarOptions pushToCedar;

    private final CedarArtifactPoster importer;

    private final CedarCsvParserFactory cedarCsvParserFactory;

    private final CliCedarArtifactWriter writer;

    private final CreateFolderRequest createFolderRequest;

    private final Map<CedarId, CedarId> artifact2GeneratedIdMap = new HashMap<>();

    private final GetClassesRequest getClassesRequest;

    private final List<LanguageCode> languageCodes;

    public Csv2ArtifactsCommand(CedarArtifactPoster importer,
                                CedarCsvParserFactory cedarCsvParserFactory,
                                CliCedarArtifactWriter writer,
                                CreateFolderRequest createFolderRequest,
                                GetClassesRequest getClassesRequest, List<LanguageCode> languageCodes) {
        this.importer = importer;
        this.cedarCsvParserFactory = cedarCsvParserFactory;
        this.writer = writer;
        this.createFolderRequest = createFolderRequest;
        this.getClassesRequest = getClassesRequest;
        this.languageCodes = languageCodes;
    }

    @Override
    public Integer call() throws Exception {
        if(jsonSchemaDescription == null) {
            jsonSchemaDescription = "Generated from " + inputCsvFile.getFileName().toString() + " by CEDAR-CSV on " + Instant.now();
        }
        if(inputCsvFile == null) {
            System.err.println("Input file not specified");
        }
        if(!Files.exists(inputCsvFile)) {
            System.err.println("Input file " + inputCsvFile + " does not exist");
            System.exit(1);
        }
        if(version == null) {
            version = VersionInfo.initialDraft().pavVersion();
        }
        if(!Files.exists(outputDirectory)) {
            Files.createDirectories(outputDirectory);
        }
        else {
            var nonEmpty = Files.list(outputDirectory).findFirst().isPresent();
            if(nonEmpty && !overwrite) {
                System.err.println("Output directory is not empty.  To overwrite existing files use the --overwrite option.");
                return 1;
            }
        }
        var inputStream = Files.newInputStream(inputCsvFile);
        var cedarCsvParser = cedarCsvParserFactory.createParser(artifactStatus,
                                                                version, previousVersion);
        try {
            var template = cedarCsvParser.parse(inputStream);

            // Write artifacts in a depth first manner

            if (generateFields) {
                var fields = template.getAllFields()
                                     .stream().filter(f -> !f.ui().inputType().equals(InputType.ATTRIBUTE_VALUE))
                                     .toList();
                writeArtifacts(fields);
            }

            if (generateElements) {
                var elements = template.getAllElements();
                writeArtifacts(elements);
            }

            writeArtifacts(List.of(template));

            writeDocs(template);

        } catch (CedarCsvParseException e) {
            System.err.println("\033[31;1mERROR: " + e.getMessage() + "\033[0m");
            System.err.println("   \033[31;1mAt: " + e.getNode().getPath().stream()
                                                          .map(CedarCsvParser.Node::getName)
                                                      .collect(Collectors.joining(" > "))+ "\033[0m");
        }

        return 0;
    }

    private void writeDocs(CedarTemplate template) throws IOException {
        var outputFile = outputDirectory.resolve("fields.md");
        var out = Files.newBufferedWriter(outputFile, Charsets.UTF_8);
        var pw = new PrintWriter(out);
        pw.println("<!-- This file has been generated from a spreadsheet.  Do not edit by hand because it will be overwritten. -->");
        pw.println();
        pw.println("""
                           <link rel="stylesheet" href="../specification.css"/>
                           """);
        pw.println();
        pw.println("# Specification");
        pw.println();
        pw.println("<h2 plain>Required fields</h2>");
        pw.println("The following fields are required fields.  These fields MUST be filled out in a metadata instance for the instance to be valid.\n");
        printFieldList(template, pw, Optionality.REQUIRED);

        pw.println("<h2 plain>Recommended fields</h2>");
        pw.println("The following fields are recommended fields.  These fields SHOULD be filled out in a metadata instance to greatly increase the likelihood of the associated data file being found by interested parties and to provide proper accreditation for the creators of the file.\n");
        printFieldList(template, pw, Optionality.RECOMMENDED);

        pw.println();

        template.nodes().forEach(n -> printArtifact(n, pw));
        pw.flush();
        pw.close();
    }

    private void printFieldList(CedarTemplate template, PrintWriter pw, Optionality opt) {
        var list = template.getAllFieldsWithPaths()
                .stream()
                .filter(p -> ((CedarTemplateField) p.get(p.size() - 1)).supplementaryInfo().optionality().equals(opt))
                           .map(p -> {
                               return p.stream()
                                       .map(n -> String.format("[%s](#%s)",
                                                               n.artifactInfo().schemaName(),
                                                               n.artifactInfo().schemaName().toLowerCase().replace(" ", "-")))
                                       .collect(Collectors.joining("  >>  "));
                           })
                .collect(Collectors.joining("\n\n"));
        pw.println(list);
    }

    private void printArtifact(EmbeddedCedarArtifact artifact, PrintWriter pw) {
        var embeddedArtifact = artifact.artifact();
        if(embeddedArtifact instanceof CedarTemplateElement element) {
            var name = element.getSchemaName();
            pw.printf("## %s", name);
            pw.println();
            printCardinalityBadge(!artifact.multiplicity().isMaxOne(), pw);
            pw.println();
            pw.println(element.getSchemaDescription());
            pw.println();
            element.nodes().forEach(a -> printArtifact(a, pw));
            pw.println();
        }
        else if(embeddedArtifact instanceof CedarTemplateField field) {
            var name = field.getSchemaName();
            pw.printf("### %s\n", name);
            printBadge(field.supplementaryInfo(), pw);
            pw.println();
            if(field.supplementaryInfo().derived().equals(Derived.DERIVED)) {
                pw.print(field.supplementaryInfo().derivedExplanation().trim());
                pw.println("  This field should not be manually specified or edited.");
                pw.println();
            }

            pw.println(field.getSchemaDescription());
            pw.println();

            if(CedarCsvInputType.LANGUAGE.equals(field.supplementaryInfo().csvInputType())) {
                pw.println("The value of this field is a language code.  See the [language code table](language-codes.md) for a list of possible language codes.");
                pw.println();
            }
            if (bioportalApiKey != null) {
                field.supplementaryInfo().getLookupSpec().ifPresent(lookupSpec -> {
                    lookupSpec.getOntologyAcronym().ifPresent(ontologyAcroymn -> {
                        var branchSpec = lookupSpec.getBranch().map(branch -> String.format("&conceptid=%s", branch)).orElse("");
                        pw.printf("Values for this field are taken from the %s ontology.  You may [use BioPortal to search for values for this field](https://bioportal.bioontology.org/ontologies/%s/?p=classes%s).", ontologyAcroymn, ontologyAcroymn, branchSpec);
                        pw.println();
                        pw.println();

                        var clsIri = lookupSpec.getBranch().orElse(null);
                        var result = getClassesRequest.execute(ontologyAcroymn, clsIri, bioportalApiKey.getApiKey());
                        if (result.totalCount() < 500) {
                            var termList = result.collection()
                                    .stream().map(entity -> String.format("[%s](%s)", entity.prefLabel(), entity.iri()))
                                    .sorted(String::compareToIgnoreCase)
                                  .collect(Collectors.joining("  |  "));
                            pw.println(termList);

                        }
                        try {
                            // Throttle.  BioPortal limits rate to 15 calls per second.
                            Thread.sleep(70);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    });
                });
            }
            var example = field.supplementaryInfo().example();
            if(!example.isBlank()) {
                pw.println("<div class=\"example\">");
                pw.println("<div class=\"example-heading\">Example</div>");
                pw.println(example);
                pw.println("</div>");
                pw.println();
            }
        }
    }

    private void printLanguageCodesTable(PrintWriter pw) {
        pw.println("|Language Code|Language|");
        pw.println("|-------------|--------|");
        languageCodes.forEach(lc -> {
            pw.printf("|%s|%s|\n", lc.code(), lc.name());
        });
        pw.println();
    }

    private void printBadge(SupplementaryInfo supplementaryInfo, PrintWriter pw) {
        if(supplementaryInfo.derived().equals(Derived.DERIVED)) {
            pw.print("""
        <span class="badge badge--derived">Derived</span>
        """);
        }
        if(supplementaryInfo.optionality().equals(Optionality.REQUIRED)) {
            pw.print("""
        <span class="badge badge--required">Required</span>
        """);
        }
        else if(supplementaryInfo.optionality().equals(Optionality.RECOMMENDED)) {
            pw.print("""
        <span class="badge badge--recommended">Recommended</span>
        """);
        }
        else {
            pw.print("""
        <span class="badge badge--optional">Optional</span>
        """);
        }
        printCardinalityBadge(supplementaryInfo.cardinality().equals(Cardinality.MULTIPLE), pw);
    }

    private void printCardinalityBadge(boolean multiple, PrintWriter pw) {
        if(multiple) {
            pw.print("""
        <span class="badge badge--multi">Multi-valued</span>
        """);
        }
    }

    private void writeArtifacts(List<? extends CedarArtifact> artifacts) {
        artifacts.forEach(this::writeCedarArtifact);
        var counter = new AtomicInteger();
        if(shouldPushToCedar()) {
            artifacts.forEach(artifact -> {
                try {
                    var initialId = artifact.id();
                    var artifactWithReplacedIds = artifact.replaceIds(artifact2GeneratedIdMap);
                    var artifactWithNullId = artifactWithReplacedIds.withId(null);
                    var posted = postArtifactToCedar(artifactWithNullId);
                    counter.incrementAndGet();
                    posted.ifPresent(r -> {
                        System.err.printf("\033[32;1mPosted\033[30;0m %s %d of %d to CEDAR\n", artifact.getSimpleTypeName().getName(), counter.get(), artifacts.size());
                        System.err.printf("    %s (id=%s)\n", r.schemaName(), r.cedarId().value());
                        if (initialId != null) {
                            artifact2GeneratedIdMap.put(initialId, r.cedarId());
                        }
                    });
                } catch (IOException | InterruptedException e) {
                    System.err.println(e.getMessage());
                }
            });
        }
    }

    private Optional<PostedArtifactResponse> postArtifactToCedar(CedarArtifact artifact) throws IOException, InterruptedException {
        var cedarFolderId = getFolderId();
        // The ID must be null.  This is because CEDAR mints it
        return importer.postToCedar(artifact, cedarFolderId,
                                    pushToCedar.getCedarApiKey(),
                                    artifact.toCompactString(), jsonSchemaDescription);
    }

    private CedarId getFolderId() {
        return pushToCedar.getCedarFolderId();
    }

    private boolean shouldPushToCedar() {
        return pushToCedar != null && pushToCedar.postToCedar;
    }

    private void writeCedarArtifact(CedarArtifact f) {
        try {
            writer.writeCedarArtifact(f, outputDirectory, jsonSchemaDescription);
        } catch (IOException e) {
            System.err.println("Could not write " + f.getSimpleTypeName().getName() + ": " + e.getMessage());
        }
    }
}
