package org.metadatacenter.cedar.cli;

import org.metadatacenter.cedar.api.ArtifactStatus;
import org.metadatacenter.cedar.api.CedarArtifact;
import org.metadatacenter.cedar.api.CedarTemplate;
import org.metadatacenter.cedar.api.VersionInfo;
import org.metadatacenter.cedar.csv.CedarCsvParserFactory;
import org.metadatacenter.cedar.io.TemplateFieldCedarImporter;
import org.springframework.stereotype.Component;
import picocli.CommandLine;
import picocli.CommandLine.ArgGroup;
import picocli.CommandLine.Command;
import picocli.CommandLine.Option;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.Instant;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Matthew Horridge
 * Stanford Center for Biomedical Informatics Research
 * 2022-07-29
 */
@Component
@Command(name = "csv2artifacts",
        description = "Generate CEDAR artifacts from a Comma Separated Values (CSV) file.  Artifacts are generated as CEDAR JSON-LD and are output as a set of JSON files.  Artifacts can also pushed directly into CEDAR.")
public class Csv2ArtifactsCommand implements CedarCliCommand {

    @Option(names = "--in", required = true, description = "A path to a CSV file that conforms to the CEDAR CSV format.")
    Path inputCsvFile;

    @Option(names = "--out", required = true, description = "A path to a directory where JSON-LD CEDAR representations of CEDAR artifacts will be written to.")
    Path outputDirectory;

    @Option(names = "--overwrite", defaultValue = "false",
            description = "Force generated artifacts to be locally overwritten if the local output directory is not empty")
    boolean overwrite;

    @Option(names = "--json-schema-description", description = "A string that will be inserted into the JSON-Schema 'description' property of all generated CEDAR artifact objects.", defaultValue = "Generated by CSV2CEDAR.")
    String jsonSchemaDescription;

    @Option(names = "--artifact-status",
            description = "Specifies the status of the artifacts that are generated.  Valid values are ${COMPLETION-CANDIDATES}",
            defaultValue = "DRAFT",
            showDefaultValue = CommandLine.Help.Visibility.ALWAYS)
    ArtifactStatus artifactStatus;

    @Option(names = "--artifact-version",
            required = true,
            description = "A string in the format major.minor.patch that specifies the version number for generatated artifacts")
    String version;

    @Option(names = "--generate-fields", defaultValue = "false",
            description = "Specifies that CEDAR template fields should be individually generated.")
    boolean generateFields;

    @Option(names = "--generate-elements", defaultValue = "false",
            description = "Specifies that individual CEDAR template elements should be individually generated.")
    boolean generateElements;



    @Option(names = "--artifact-previous-version", defaultValue = "", hidden = true)
    public String previousVersion;

    @ArgGroup(exclusive = false,
            heading = "CEDAR Connection Details")
    public PushToCedarOptions pushToCedar;

    private final TemplateFieldCedarImporter importer;

    private final CedarCsvParserFactory cedarCsvParserFactory;

    private final CliCedarArtifactWriter writer;


    public Csv2ArtifactsCommand(TemplateFieldCedarImporter importer,
                                CedarCsvParserFactory cedarCsvParserFactory,
                                CliCedarArtifactWriter writer) {
        this.importer = importer;
        this.cedarCsvParserFactory = cedarCsvParserFactory;
        this.writer = writer;
    }

    @Override
    public Integer call() throws Exception {
        if(jsonSchemaDescription == null) {
            jsonSchemaDescription = "Generated from " + inputCsvFile.getFileName().toString() + " by CEDAR-CSV on " + Instant.now();
        }
        if(inputCsvFile == null) {
            System.err.println("Input file not specified");
        }
        if(!Files.exists(inputCsvFile)) {
            System.err.println("Input file " + inputCsvFile + " does not exist");
            System.exit(1);
        }
        if(version == null) {
            version = VersionInfo.initialDraft().pavVersion();
        }
        if(!Files.exists(outputDirectory)) {
            Files.createDirectories(outputDirectory);
        }
        else {
            var nonEmpty = Files.list(outputDirectory).findFirst().isPresent();
            if(nonEmpty && !overwrite) {
                System.err.println("Output directory is not empty.  To overwrite existing files use the --overwrite option.");
                return 1;
            }

        }
        var inputStream = Files.newInputStream(inputCsvFile);
        var cedarCsvParser = cedarCsvParserFactory.createParser(artifactStatus,
                                                                version, previousVersion);
        var template = cedarCsvParser.parse(inputStream);

        template = new CedarTemplate(template.id(),
                                     template.artifactInfo(),
                                     template.versionInfo(),
                                     template.modificationInfo(),
                                     template.nodes().stream().toList());

        writeCedarArtifact(template);
//        if (shouldPushToCedar()) {
//            pushArtifactToCedar(template);
//        }

        if (generateElements) {
            var elements = template.getElements();
            writeArtifacts(elements);
        }


        if (generateFields) {
            var fields = template.getFields();
            writeArtifacts(fields);
        }
        return 0;
    }

    private void writeArtifacts(List<? extends CedarArtifact> artifacts) {
        artifacts.forEach(this::writeCedarArtifact);
        var counter = new AtomicInteger();
        if(shouldPushToCedar()) {
            artifacts.forEach(artifact -> {
                try {
                    pushArtifactToCedar(artifact);
                    counter.incrementAndGet();
                    System.err.printf("Posted %d %s of %d to CEDAR\n", counter.get(), artifact.getSimpleTypeName().getName(), artifacts.size());
                } catch (IOException | InterruptedException e) {
                    System.err.println(e.getMessage());
                }
            });
        }
    }

    private void pushArtifactToCedar(CedarArtifact artifact) throws IOException, InterruptedException {
        importer.postToCedar(artifact, pushToCedar.getCedarFolderId(),
                             pushToCedar.getCedarApiKey(),
                             artifact.toCompactString(), jsonSchemaDescription);
    }

    private boolean shouldPushToCedar() {
        return pushToCedar != null && pushToCedar.pushToCedar;
    }

    private void writeCedarArtifact(CedarArtifact f) {
        try {
            writer.writeCedarArtifact(f, outputDirectory, jsonSchemaDescription);
        } catch (IOException e) {
            System.err.println("Could not write field " + e.getMessage());
        }
    }
}
